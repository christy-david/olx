{"version":3,"sources":["webpack://kolo/./src/utils.ts","webpack://kolo/./src/build-frame-tree.ts","webpack://kolo/./node_modules/msgpackr/unpack.js","webpack://kolo/./node_modules/msgpackr/pack.js","webpack://kolo/./src/extension/msgpack.ts","webpack://kolo/./node_modules/svelte/internal/index.mjs","webpack://kolo/./src/webapp/WebApp.svelte","webpack://kolo/./src/webapp/index.ts"],"names":["dfsWithParent","treeNodes","parent","node","children","callLikeFramesOfInterest","returnLikeFramesOfInterest","leafFramesOfInterest","makeExecutionTree","framesOfInterest","length","executionTreeNodes","totalExecutionTreeNodeCount","sql_queries","outbound_http_requests","background_jobs","log_messages","rootExecutionTreeNodes","currentAncestors","executionTreeNodeIndex","nonFrameInformationOfInterest","five_hundred_exception","outbound_http_request_index","sql_query_index","log_message_index","preProcessFramesOfInterest","forEach","frameOfInterest","isReturnFrame","event","isCall","type","includes","isReturn","currentTreeNode","makeTreeNode","push","currentParentIndex","currentParent","console","log","JSON","stringify","expectedParentType","Error","expectedParentTypes","django_response","end_sql_query","outbound_http_response","end_test","django_template_end","background_job_end","django_setup_end","django_checks_end","django_create_test_db_end","expectedParentTpe","allFramesOfInterest","debugOutput","frameMisMatchDebugInfo","frame_id","name","throwMissingReturnFrame","expectedFrameId","actualFrameId","debug","data","return_frame","response","annotatedChildren","exceptionFrameSpanIndex","exception","index","exceptionFrame","exception_frames","entries","isBottomExceptionFrame","path","co_name","exceptionMessage","getExceptionMessageFromException","undefined","annotateFrameSpansWith500ExceptionInfo","five_hundred_exception_frame_span_index","frameOfInterestName","query","query_template","query_data","database","return_timestamp","body","headers","timestamp","status_code","grandParent","return_context","context","pop","ancestor","nodes","removeChildrenOfTheseNodes","dfsGenerator","filter","child","root","postProcess","setChildrenCounts","reduce","sum","treeNode","all_children_count","exception_summary","qualname","test_name","template","method","path_info","msg","method_and_full_url","base","call_frame","request","user_code_call_site","call_timestamp","subtype","url","test_class","call_context","args","kwargs","level","extra","stack","traceback","fns","input","acc","fn","pipe","frame","backgroundJobCount","backgroundJobEndCount","array","String","nextItem","shallowSum","calculateAllChildrenCount","currentParentFrameId","currentReturnFrameOfInterestFrameId","frameMisMatchDebugOutput","intermediateFrameCount","indentationStack","callOrReturn","indent","repeat","join","decoder","src","srcEnd","TextDecoder","error","position","EMPTY_ARRAY","currentStructures","srcString","bundledStrings","referenceMap","dataView","strings","stringPosition","currentUnpackr","srcStringStart","srcStringEnd","currentExtensions","defaultOptions","useRecords","mapsAsObjects","C1Type","C1","sequentialMode","inlineObjectReadThreshold","Function","Infinity","constructor","options","sequential","trusted","structures","maxSharedStructures","sharedLength","getStructures","uninitialized","int64AsNumber","int64AsType","Object","assign","this","unpack","source","saveState","clearSource","prototype","call","buffer","ArrayBuffer","Buffer","from","Uint8Array","end","start","DataView","byteOffset","byteLength","checkedRead","unpackMultiple","values","lastPosition","size","value","defaultUnpackr","_mergeStructures","loadedStructures","existingStructures","isFrozen","map","structure","slice","i","l","isShared","highByte","id","existing","restoreStructures","decode","result","randomAccessStructure","read","postBundlePosition","jsonView","_","RangeError","message","startsWith","incomplete","token","loadStructures","createStructureReader","object","key","readKey","Map","set","Array","freezeData","freeze","string","shortStringInJS","longStringInJS","readFixedString","position1","position0","readBin","getUint16","getUint32","readExt","getFloat32","useFloat32","multiplier","mult10","getFloat64","getBigUint64","toString","BigInt","Number","getInt8","getInt16","getInt32","getBigInt64","recordDefinition","extension","noBuffer","subarray","readString8","readString16","readString32","readArray","readMap","validName","firstId","readObject","count","test","createSecondByteReader","read0","readStringJS","units","byte1","byte2","byte3","unit","fromCharCode","apply","bytes","byte","a","b","c","d","e","f","g","h","j","k","m","n","o","readOnlyJSString","copyBuffers","readPosition","keyCache","chunk","entry","checkPosition","property","firstByte","existingStructure","errors","TypeError","ReferenceError","target","refEntry","targetProperties","used","get","Set","typedArrays","glbl","globalThis","window","typeCode","typedArrayName","RegExp","TEMP_BUNDLE","callback","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedStructuresContents","savedPackr","savedSequentialMode","splice","dataSize","dataPosition","Date","Math","floor","textEncoder","extensions","extensionClasses","f32Array","Float32Array","TextEncoder","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","keysTarget","targetView","safeEnd","hasNonLatin","RECORD_SYMBOL","Symbol","hasSharedUpdate","super","offset","encodeUtf8","utf8Write","encodeInto","written","packr","isSequential","hasSharedStructures","saveStructures","structuredClone","moreTypes","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","pack","encode","encodeOptions","RESERVE_START_SPACE","bundleStrings","transitions","create","keys","nextTransition","transition","lastNamedStructuresLength","nextId","writeStruct","lastBundle","writeBundles","idsToInsert","sort","incrementPosition","insertionPoint","stringsPosition","setUint32","previous","makeRoom","serialized","distanceToMove","lastEnd","copyWithin","insertIds","REUSE_BUFFER_MODE","resetStructures","returnBuffer","newSharedData","isCompatible","compatible","prepareStructures","RESET_BUFFER_MODE","packArray","headerSize","strLength","extStart","maxBytes","setUint16","twoByte","c1","c2","strPosition","charCodeAt","setInt16","setInt32","xShifted","setFloat32","setFloat64","referee","writeObject","mapAsEmptyObject","entryValue","write","writeResult","isArray","currentTarget","currentTargetView","currentPosition","writeExtensionData","toJSON","json","writeFunction","hasOwnProperty","setBigInt64","setBigUint64","largeBigIntToFloat","encodeUndefinedAsNil","writePlainObject","variableMapSize","coercibleKeyAsNumber","num","isNaN","safePrototype","objectOffset","writeRecord","progressiveRecords","wroteKeys","lastTransition","newTransitions","newRecord","insertNewRecord","recordId","__keys__","checkUseRecords","newSize","min","round","max","newBuffer","copy","shouldShareStructure","nextOwnId","shift","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","writeStructSlots","notifySharedUpdate","startTarget","useBuffer","clearSharedData","typedStructs","writeExtBuffer","typedArray","allocateForWrite","writeBuffer","writeStrings","Class","unshift","getPrototypeOf","date","seconds","getTime","useTimestamp32","getMilliseconds","onInvalidDate","setAsEmptyObject","regex","flags","arrayBuffer","indexOf","defaultPackr","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT","noop","run","blank_object","run_all","is_function","thing","safe_not_equal","is_empty","obj","hex","highbyte","parseInt","bn","split","hexToBigInt","globals","global","ResizeObserverSingleton","_listeners","WeakMap","observe","element","listener","_getObserver","delete","_observer","unobserve","_a","ResizeObserver","current_component","is_hydrating","detach","parentNode","removeChild","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","seen_callbacks","flushidx","flush","saved_component","update","$$","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","SvelteElement","destroy_component","detaching","filtered","targets","flush_render_callbacks","on_destroy","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_mount","on_disconnect","callbacks","skip_bound","ready","ret","rest","then","fill","make_dirty","hydrate","childNodes","intro","block","local","anchor","customElement","new_on_destroy","mount_component","HTMLElement","attachShadow","mode","connectedCallback","slotted","appendChild","attributeChangedCallback","attr","_oldValue","newValue","disconnectedCallback","$destroy","$on","$set","$$props","$$set","SvelteComponent","attribute","document","createElement","removeAttribute","getAttribute","setAttribute","insertBefore","loadVizForTrace","traceId","trace","fetch","parsed_trace","tree","frames_of_interest","dispatchEvent","CustomEvent","detail","addEventListener","getElementById","latest_traces","innerHTML","traces","trace_id","traceElements","getElementsByClassName","traceElement","matchMedia","command"],"mappings":"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","file":"main.js","sourcesContent":["import type { TextDocument } from \"vscode\";\nimport type { Frame } from \"./frames-of-interest-model\";\n\nimport type { ExecutionTreeNode, FrameSpan } from \"./model\";\n\ninterface LineAndPath {\n  line: number;\n  path: string;\n}\n\nexport function getLineNumberAndPath(frame: Frame): LineAndPath {\n  const pathWithLineNumber = frame.path;\n\n  const [path, line] = pathWithLineNumber.split(\":\");\n\n  return { path, line: parseInt(line) };\n}\n\nexport function getLineCount(document: string): number {\n  return (String(document).match(/\\n/g) || \"\").length + 1;\n}\n\nexport function findRelevantFrames(\n  frames: Frame[],\n  document: TextDocument\n): Frame[] {\n  const relevantFrames: Frame[] = [];\n  const fileName = document.fileName;\n  frames.forEach((frame) => {\n    const { path } = getLineNumberAndPath(frame);\n    // TODO: Make this more sophisticated in the future. endsWith might not always be exactly right\n    if (fileName.endsWith(path)) {\n      relevantFrames.push(frame);\n    }\n  });\n\n  return relevantFrames;\n}\n\nexport function justFrameSpans(treeNodes: ExecutionTreeNode[]): FrameSpan[] {\n  return treeNodes\n    .map((node) => {\n      if (node.type !== \"frame_span\") {\n        return justFrameSpans(node.children);\n      }\n\n      const children = justFrameSpans(node.children);\n      return {\n        index: node.index,\n        name: node.name,\n        children: children,\n        // The all_children_count here are wrong. But that's OK for now..\n        all_children_count: node.all_children_count,\n        call_frame: node.data.call_frame,\n        return_frame: node.data.return_frame,\n      };\n    })\n    .flat();\n}\n\nexport function* dfs(\n  treeNodes: ExecutionTreeNode[]\n): Generator<ExecutionTreeNode> {\n  for (const node of treeNodes) {\n    yield node;\n    yield* dfs(node.children);\n  }\n}\n\nexport function* dfsWithParent(\n  treeNodes: ExecutionTreeNode[],\n  parent: ExecutionTreeNode | null = null\n): Generator<[ExecutionTreeNode, ExecutionTreeNode | null]> {\n  for (const node of treeNodes) {\n    yield [node, parent];\n    yield* dfsWithParent(node.children, node);\n  }\n}\n","import type {\n  FrameOfInterest,\n  ExecutionTreeInfo,\n  NonFrameInformationOfInterest,\n  EndSQLQuery,\n} from \"./frames-of-interest-model\";\nimport type {\n  ExecutionTreeNode,\n  FiveHundredException,\n  NestedOutboundRequest,\n  NestedBackgroundJobData,\n  FrameSpanData,\n  NestedSQLQuery,\n  NestedBackgroundJob,\n  NestedLogMessage,\n} from \"./model\";\nimport { dfsWithParent } from \"./utils\";\n\nconst callLikeFramesOfInterest = [\n  \"django_request\",\n  \"start_sql_query\",\n  \"outbound_http_request\",\n  \"start_test\",\n  \"django_template_start\",\n  \"background_job\",\n  \"django_setup_start\",\n  \"django_checks_start\",\n  \"django_create_test_db_start\",\n];\nconst returnLikeFramesOfInterest = [\n  \"django_response\",\n  \"end_sql_query\",\n  \"outbound_http_response\",\n  \"end_test\",\n  \"django_template_end\",\n  \"background_job_end\",\n  \"django_setup_end\",\n  \"django_checks_end\",\n  \"django_create_test_db_end\",\n];\n\nconst leafFramesOfInterest = [\"log_message\"];\n\nexport function makeExecutionTree(\n  framesOfInterest: FrameOfInterest[]\n): ExecutionTreeInfo {\n  if (framesOfInterest.length === 0) {\n    return {\n      executionTreeNodes: [],\n      totalExecutionTreeNodeCount: 0,\n      sql_queries: [],\n      outbound_http_requests: [],\n      background_jobs: [],\n      log_messages: [],\n    };\n  }\n\n  const rootExecutionTreeNodes: ExecutionTreeNode[] = [];\n\n  // Last ancestor in this list is the current parent\n  const currentAncestors: ExecutionTreeNode[] = [];\n\n  let executionTreeNodeIndex: number = 0;\n\n  const nonFrameInformationOfInterest = {\n    sql_queries: [],\n    outbound_http_requests: [],\n    background_jobs: [],\n    log_messages: [],\n  } as NonFrameInformationOfInterest;\n\n  let outbound_http_request_index = 0;\n  let sql_query_index = 0;\n  let log_message_index = 0;\n  let five_hundred_exception: FiveHundredException | undefined = undefined;\n\n  framesOfInterest = preProcessFramesOfInterest(framesOfInterest);\n\n  framesOfInterest.forEach((frameOfInterest) => {\n    const isReturnFrame =\n      \"event\" in frameOfInterest && frameOfInterest.event === \"return\";\n    const isCallFrame =\n      \"event\" in frameOfInterest && frameOfInterest.event === \"call\";\n\n    const isCall =\n      isCallFrame ||\n      (frameOfInterest.type &&\n        callLikeFramesOfInterest.includes(frameOfInterest.type));\n\n    const isReturn =\n      isReturnFrame ||\n      (frameOfInterest.type &&\n        returnLikeFramesOfInterest.includes(frameOfInterest.type));\n\n    if (isCall) {\n      if (currentAncestors.length === 0) {\n        // If there are no currentAncestors, we're entering a new root-level subtree\n\n        const currentTreeNode = makeTreeNode(\n          frameOfInterest,\n          executionTreeNodeIndex\n        );\n        currentAncestors.push(currentTreeNode);\n\n        executionTreeNodeIndex += 1;\n        return;\n      } else {\n        // We have a parent, so this new ExecutionTreeNode is a child of this parent\n\n        const currentParentIndex = currentAncestors.length - 1;\n        const currentParent = currentAncestors[currentParentIndex];\n\n        const currentTreeNode = makeTreeNode(\n          frameOfInterest,\n          executionTreeNodeIndex\n        );\n        currentParent.children.push(currentTreeNode);\n\n        currentAncestors.push(currentTreeNode);\n\n        executionTreeNodeIndex += 1;\n        return;\n      }\n    } else if (isReturn) {\n      if (currentAncestors.length === 0) {\n        // We find ourselves in a return_frame but with no\n        // corresponding call_frame. It's unclear under which\n        // circumstances this would currently happen, but we\n        // don't support it yet. Currently we just throw away this return frame.\n        console.log(\n          \"Kolo warning: Throwing away return_frame with no corresponding_call frame\" +\n            JSON.stringify(frameOfInterest, null, 2)\n        );\n        return;\n\n        // I think feasibly we could also have a call statement without a return statement??\n        // In that case we \"wouldn't have fully completed the subtree\" so this is a case\n        // where we might currently show 0 frames\n      }\n\n      const currentParentIndex = currentAncestors.length - 1;\n      const currentParent = currentAncestors[currentParentIndex];\n\n      const expectedParentType = expectedParentTpe(frameOfInterest);\n      if (currentParent.type !== expectedParentType) {\n        throwMissingReturnFrame(\n          currentParent,\n          frameOfInterest,\n          framesOfInterest\n        );\n      } else {\n        // We're just silently logging this for now, possibly we'd like to fail hard\n        // in case the frame ids don't match in the future.\n        const expectedFrameId = currentParent.frame_id;\n        const actualFrameId = frameOfInterest.frame_id;\n        if (expectedFrameId !== actualFrameId) {\n          const debug = frameMisMatchDebugInfo(\n            currentParent,\n            frameOfInterest,\n            framesOfInterest\n          );\n          console.log(\n            `Kolo warning: frame_id mismatch. Expected ${expectedFrameId}, got ${actualFrameId}\\n` +\n              debug\n          );\n        }\n      }\n\n      if (isReturnFrame) {\n        currentParent.data.return_frame = frameOfInterest;\n      } else if (frameOfInterest?.type === \"django_response\") {\n        currentParent.data.response = frameOfInterest;\n\n        if (five_hundred_exception) {\n          currentParent.data.five_hundred_exception = five_hundred_exception;\n\n          const { annotatedChildren, exceptionFrameSpanIndex } =\n            annotateFrameSpansWith500ExceptionInfo(\n              currentParent.children,\n              five_hundred_exception\n            );\n          currentParent.children = annotatedChildren;\n\n          // exceptionFrameSpanIndex will be undefined if the trace has no exception\n          // or if we can't match the bottom exception frame to a recorded frame.\n          // If we can't match the bottom exception frame to a recorded frame,\n          // there will be a warning in the console output.\n          currentParent.data.five_hundred_exception_frame_span_index =\n            exceptionFrameSpanIndex;\n\n          five_hundred_exception = undefined;\n        }\n\n        // Future TODO: What if we don't have a response?\n        // Can that ever happen? Should we then skip that?\n      } else if (frameOfInterest?.type === \"end_sql_query\") {\n        currentParent.data.index = sql_query_index;\n        sql_query_index += 1;\n\n        // Unlike for other types, setting the name here since only the end_sql_query\n        // has the query information and can thus set a decent name.\n        currentParent.name = frameOfInterestName(frameOfInterest);\n\n        currentParent.data.query = frameOfInterest.query;\n        currentParent.data.query_template = frameOfInterest.query_template;\n        currentParent.data.query_data = frameOfInterest.query_data;\n        currentParent.data.database = frameOfInterest.database;\n        currentParent.data.return_timestamp = frameOfInterest.return_timestamp;\n        nonFrameInformationOfInterest.sql_queries.push(\n          currentParent as NestedSQLQuery\n        );\n      } else if (frameOfInterest?.type === \"outbound_http_response\") {\n        currentParent.data.index = outbound_http_request_index;\n        outbound_http_request_index += 1;\n\n        currentParent.data.response = {\n          body: frameOfInterest.body,\n          headers: frameOfInterest.headers,\n          timestamp: frameOfInterest.timestamp,\n          status_code: frameOfInterest.status_code,\n        };\n        // Hide a urllib3 outbound http request when it is nested in a requests outbound http request.\n        // The urllib3 request is still in the ExecutionTreeNode tree but is hidden from users due to\n        // how NestedOutboundRequest is implemented in the visualisation and the sidebar.\n        const grandParent = currentAncestors[currentParentIndex - 1] as\n          | ExecutionTreeNode\n          | undefined;\n        if (grandParent?.type !== \"outbound_http_request\") {\n          nonFrameInformationOfInterest.outbound_http_requests.push(\n            currentParent as NestedOutboundRequest\n          );\n        }\n      } else if (frameOfInterest?.type === \"end_test\") {\n        currentParent.data.return_timestamp = frameOfInterest.timestamp;\n      } else if (frameOfInterest?.type === \"django_template_end\") {\n        currentParent.data.return_timestamp = frameOfInterest.timestamp;\n        currentParent.data.return_context = frameOfInterest.context;\n      } else if (frameOfInterest?.type === \"background_job_end\") {\n        currentParent.data.return_timestamp = frameOfInterest.timestamp;\n\n        nonFrameInformationOfInterest.background_jobs.push(\n          currentParent as NestedBackgroundJob\n        );\n      } else if (frameOfInterest?.type === \"django_setup_end\") {\n        currentParent.data.return_timestamp = frameOfInterest.timestamp;\n      } else if (frameOfInterest?.type === \"django_checks_end\") {\n        currentParent.data.return_timestamp = frameOfInterest.timestamp;\n      } else if (frameOfInterest?.type === \"django_create_test_db_end\") {\n        currentParent.data.return_timestamp = frameOfInterest.timestamp;\n      } else {\n        throw new Error(\n          \"Unexpected return-like frame of interest\" +\n            JSON.stringify(frameOfInterest, null, 2)\n        );\n      }\n\n      // We have returned, so successfully combined this subtree\n      const currentTreeNode = currentAncestors.pop();\n      if (!currentTreeNode) {\n        throw new Error(\"currentTreeNode is unexpectedly falsy\");\n      }\n\n      if (currentAncestors.length === 0) {\n        // We only add to rootExecutionTreeNodes if we've fully completed\n        // a root-level subtree\n        rootExecutionTreeNodes.push(currentTreeNode);\n      }\n    } else if (\n      frameOfInterest.type &&\n      leafFramesOfInterest.includes(frameOfInterest.type)\n    ) {\n      // Leaf nodes fall out of the usual call/return model so we handle them separately here.\n\n      const currentParentIndex = currentAncestors.length - 1;\n      const currentParent = currentAncestors[currentParentIndex];\n\n      const currentTreeNode = makeTreeNode(\n        frameOfInterest,\n        executionTreeNodeIndex\n      );\n\n      if (currentTreeNode.type === \"log_message\") {\n        currentTreeNode.data.index = log_message_index;\n        log_message_index += 1;\n\n        nonFrameInformationOfInterest.log_messages.push(\n          currentTreeNode as NestedLogMessage\n        );\n      }\n\n      const currentParentExists = currentParentIndex >= 0;\n      if (currentParentExists) {\n        // Often, we have a current parent, that's what this branch handles:\n        // We attach the complete node as a child to the current parent and won't modify it again later.\n        currentParent.children.push(currentTreeNode);\n      } else {\n        // But it's possible that the first thing that happens when a program\n        // starts up is that it logs a message.\n        // In that case the single leaf node would be the first complete root-level\n        // subtree, which we handle here.\n        rootExecutionTreeNodes.push(currentTreeNode);\n      }\n\n      executionTreeNodeIndex += 1;\n      return;\n    } else if (frameOfInterest.type === \"exception\") {\n      // A 500 exception or \"exception\" in frames_of_interest can occur once per request\n      // and describes the specific case where an exception caused django to serve a 500\n      // \"exception\" appears as a single entry in frames_of_interest (at most once per request)\n      // And is handled as a special case, as opposed to as a leaf node.\n\n      five_hundred_exception = frameOfInterest;\n    } else {\n      // @ts-ignore\n      if (!frameOfInterest.type === \"sql_query_data\") {\n        console.debug(\n          // @ts-ignore\n          `Unexpected frames_of_interest type: ${\n            frameOfInterest.type\n          }, ${JSON.stringify(frameOfInterest, null, 2)}`\n        );\n      }\n    }\n  });\n\n  if (currentAncestors.length !== 0) {\n    // We have not completed some subtrees. Any frames in these incomplete subtrees\n    // are not propagated to the rootExecutionTreeNodes and as such not surfaced\n    // to the user.\n\n    console.log(\"Kolo Warning: incomplete subtrees exist\");\n    currentAncestors.forEach((ancestor, index) => {\n      console.log(index, ancestor.children.length, ancestor.name);\n    });\n    // In an ideal world we could surface this to the user directly in the sidebar\n  }\n\n  const executionTreeNodes = postProcess(rootExecutionTreeNodes);\n  setChildrenCounts(executionTreeNodes);\n\n  return {\n    executionTreeNodes,\n    totalExecutionTreeNodeCount:\n      totalExecutionTreeNodeCount(executionTreeNodes),\n    ...nonFrameInformationOfInterest,\n  };\n}\n\nexport function getNumberOfLines(str: string) {\n  const lines = str.length - str.replace(/\\n/g, \"\").length;\n\n  return lines;\n}\n\nexport function getExceptionMessageFromException(\n  exception: FiveHundredException\n): string {\n  const { exception_summary } = exception;\n  return exception_summary[exception_summary.length - 1];\n}\n\nfunction frameOfInterestName(frameOfInterest: FrameOfInterest): string {\n  // Used for \"{name} and 123 other calls\" display in the sidebar/webview label and in compact tree\n\n  const unrenderedTypes = [\n    \"start_sql_query\", // we use \"end_sql_query\" instead\n    \"django_setup_start\",\n    \"django_checks_start\",\n    \"django_create_test_db_start\",\n  ];\n\n  if (frameOfInterest.type === undefined || frameOfInterest.type === \"frame\") {\n    return (\n      frameOfInterest.qualname ??\n      `${frameOfInterest.path} ${frameOfInterest.co_name}`\n    );\n  } else if (\n    frameOfInterest.type === \"start_test\" ||\n    frameOfInterest.type === \"end_test\"\n  ) {\n    return `${frameOfInterest.test_name}`;\n  } else if (\n    frameOfInterest.type === \"django_template_start\" ||\n    frameOfInterest.type === \"django_template_end\"\n  ) {\n    return `${frameOfInterest.template}`;\n  } else if (frameOfInterest.type === \"django_request\") {\n    return `${frameOfInterest.method} ${frameOfInterest.path_info}`;\n  } else if (frameOfInterest.type === \"log_message\") {\n    return frameOfInterest.msg;\n  } else if (frameOfInterest.type === \"end_sql_query\") {\n    return `${frameOfInterest.query} (${frameOfInterest.frame_id})`;\n  } else if (frameOfInterest.type === \"outbound_http_request\") {\n    return `${frameOfInterest.method_and_full_url}`;\n  } else if (\n    frameOfInterest.type === \"background_job\" ||\n    frameOfInterest.type === \"background_job_end\"\n  ) {\n    return `${frameOfInterest.name}`;\n  } else if (unrenderedTypes.includes(frameOfInterest.type)) {\n    return `${frameOfInterest.type}`;\n  } else {\n    console.log(\n      `Consider specifying a better frameOfInterestName for: ${frameOfInterest.type}`\n    );\n    return `${frameOfInterest.type}`;\n  }\n}\n\nfunction calculateAllChildrenCount(treeNode: ExecutionTreeNode): number {\n  const shallowSum = treeNode.children.reduce(\n    (sum: number, node: ExecutionTreeNode) => sum + node.all_children_count,\n    0\n  );\n\n  return treeNode.children.length + shallowSum;\n}\n\nexport function totalExecutionTreeNodeCount(\n  treeNodes: ExecutionTreeNode[]\n): number {\n  return treeNodes.reduce(\n    (sum, treeNode) => sum + (1 + treeNode.all_children_count),\n    0\n  );\n}\n\nfunction makeTreeNode(\n  frameOfInterest: FrameOfInterest,\n  executionTreeNodeIndex: number\n): ExecutionTreeNode {\n  const base = {\n    index: executionTreeNodeIndex,\n    name: frameOfInterestName(frameOfInterest),\n    children: [],\n    all_children_count: 0,\n    frame_id: frameOfInterest.frame_id,\n  };\n  if (\"event\" in frameOfInterest && frameOfInterest.event === \"call\") {\n    return {\n      ...base,\n      type: \"frame_span\",\n      data: {\n        call_frame: frameOfInterest,\n      },\n    };\n  } else if (frameOfInterest?.type === \"django_request\") {\n    return {\n      ...base,\n      type: \"nested_served_http_request\",\n      data: {\n        request: frameOfInterest,\n      },\n    };\n  } else if (frameOfInterest?.type === \"start_sql_query\") {\n    return {\n      ...base,\n      type: \"sql_query\",\n      data: {\n        user_code_call_site: frameOfInterest.user_code_call_site,\n        call_timestamp: frameOfInterest.call_timestamp,\n      },\n    };\n  } else if (frameOfInterest?.type === \"outbound_http_request\") {\n    return {\n      ...base,\n      type: \"outbound_http_request\",\n      subtype: frameOfInterest.subtype,\n      data: {\n        request: {\n          url: frameOfInterest.url,\n          body: frameOfInterest.body,\n          method: frameOfInterest.method,\n          headers: frameOfInterest.headers,\n          timestamp: frameOfInterest.timestamp,\n          method_and_full_url: frameOfInterest.method_and_full_url,\n        },\n      },\n    };\n  } else if (frameOfInterest?.type === \"start_test\") {\n    return {\n      ...base,\n      type: \"nested_test\",\n      data: {\n        test_name: frameOfInterest.test_name,\n        test_class: frameOfInterest.test_class,\n        call_timestamp: frameOfInterest.timestamp,\n      },\n    };\n  } else if (frameOfInterest?.type === \"django_template_start\") {\n    return {\n      ...base,\n      type: \"django_template\",\n      data: {\n        call_timestamp: frameOfInterest.timestamp,\n        template: frameOfInterest.template,\n        call_context: frameOfInterest.context,\n      },\n    };\n  } else if (frameOfInterest?.type === \"background_job\") {\n    const data: Omit<NestedBackgroundJobData, \"return_timestamp\"> = {\n      call_timestamp: frameOfInterest.timestamp,\n      name: frameOfInterest.name,\n      args: frameOfInterest.args,\n      kwargs: frameOfInterest.kwargs,\n      subtype: frameOfInterest.subtype,\n    };\n\n    return {\n      ...base,\n      type: \"nested_background_job\",\n      data,\n    };\n  } else if (frameOfInterest?.type === \"log_message\") {\n    return {\n      ...base,\n      type: \"log_message\",\n      data: {\n        level: frameOfInterest.level,\n        args: frameOfInterest.args,\n        extra: frameOfInterest.extra,\n        msg: frameOfInterest.msg,\n        stack: frameOfInterest.stack,\n        traceback: frameOfInterest.traceback,\n      },\n    };\n  } else if (frameOfInterest?.type === \"django_setup_start\") {\n    return {\n      ...base,\n      type: \"django_setup\",\n      data: {},\n    };\n  } else if (frameOfInterest?.type === \"django_checks_start\") {\n    return {\n      ...base,\n      type: \"django_checks\",\n      data: {},\n    };\n  } else if (frameOfInterest?.type === \"django_create_test_db_start\") {\n    return {\n      ...base,\n      type: \"django_create_test_db\",\n      data: {},\n    };\n  } else {\n    throw new Error(\n      \"Unexpected frameOfInterest: \" + JSON.stringify(frameOfInterest, null, 2)\n    );\n  }\n}\n\nfunction expectedParentTpe(frameOfInterest: FrameOfInterest): string {\n  if (\"event\" in frameOfInterest && frameOfInterest.event === \"return\") {\n    return \"frame_span\";\n  } else if (\"event\" in frameOfInterest && frameOfInterest.event === \"call\") {\n    throw new Error(\n      \"Unexpected parent check for call frameOfInterest\" +\n        JSON.stringify(frameOfInterest, null, 2)\n    );\n  }\n\n  if (callLikeFramesOfInterest.includes(frameOfInterest.type)) {\n    throw new Error(\n      \"Unexpected parent check for call-like frameOfInterest\" +\n        JSON.stringify(frameOfInterest, null, 2)\n    );\n  }\n  if (leafFramesOfInterest.includes(frameOfInterest.type)) {\n    throw new Error(\n      \"Unexpected parent check for leaf frameOfInterest\" +\n        JSON.stringify(frameOfInterest, null, 2)\n    );\n  }\n\n  const expectedParentTypes = {\n    django_response: \"nested_served_http_request\",\n    end_sql_query: \"sql_query\",\n    outbound_http_response: \"outbound_http_request\",\n    end_test: \"nested_test\",\n    django_template_end: \"django_template\",\n    background_job_end: \"nested_background_job\",\n    django_setup_end: \"django_setup\",\n    django_checks_end: \"django_checks\",\n    django_create_test_db_end: \"django_create_test_db\",\n  };\n\n  if (frameOfInterest.type in expectedParentTypes) {\n    // @ts-ignore\n    return expectedParentTypes[frameOfInterest.type];\n  } else {\n    throw new Error(\n      \"Unexpected frameOfInterest when determining parent type: \" +\n        JSON.stringify(frameOfInterest, null, 2)\n    );\n  }\n}\n\nfunction annotateFrameSpansWith500ExceptionInfo(\n  executionTreeNodes: ExecutionTreeNode[],\n  exception: FiveHundredException\n): {\n  annotatedChildren: ExecutionTreeNode[];\n  exceptionFrameSpanIndex: number | undefined;\n} {\n  for (const [index, exceptionFrame] of exception.exception_frames.entries()) {\n    const isBottomExceptionFrame =\n      index === exception.exception_frames.length - 1;\n\n    let children = executionTreeNodes;\n    for (const node of children) {\n      if (node.type !== \"frame_span\") {\n        continue;\n      }\n      const { return_frame } = node.data as FrameSpanData;\n      if (\n        return_frame.path === exceptionFrame.path &&\n        return_frame.co_name === exceptionFrame.co_name\n      ) {\n        if (isBottomExceptionFrame) {\n          node.data.return_frame.exception = exception;\n          return {\n            annotatedChildren: executionTreeNodes,\n            exceptionFrameSpanIndex: node.index,\n          };\n        } else {\n          return_frame.exceptionMessage =\n            getExceptionMessageFromException(exception);\n        }\n\n        // Enter the next for (const node of children) loop with a new value for children\n        children = node.children;\n        break;\n      }\n    }\n\n    // This happens so often and the exception matching is so fragile that I'm going to\n    // disable this for now.\n    // console.log(\n    //   \"Warning: Could not find frame matching exception frame\" +\n    //     JSON.stringify(exceptionFrame, null, 2)\n    // );\n  }\n\n  // If we can't find the frame we expect, then we bail and return the executionTreeNodes unmodified\n  return {\n    annotatedChildren: executionTreeNodes,\n    exceptionFrameSpanIndex: undefined,\n  };\n}\n\nfunction removeLegacyUrllibFrames() {\n  return (framesOfInterest: FrameOfInterest[]): FrameOfInterest[] => {\n    return framesOfInterest.filter((frame) => {\n      // We need to filter out these urlopen frames because otherwise\n      // outbound_http_request and outbound_http_response are not next to each other\n      if (\n        \"qualname\" in frame &&\n        frame.qualname === \"urllib3.connectionpool.HTTPConnectionPool.urlopen\"\n      ) {\n        return false;\n      } else {\n        return true;\n      }\n    });\n  };\n}\n\nfunction removeLegacyBackgroundJobFrames() {\n  return (framesOfInterest: FrameOfInterest[]): FrameOfInterest[] => {\n    let backgroundJobCount = 0;\n    let backgroundJobEndCount = 0;\n    framesOfInterest.forEach((frame) => {\n      if (frame.type === \"background_job\") {\n        backgroundJobCount++;\n      } else if (frame.type === \"background_job_end\") {\n        backgroundJobEndCount++;\n      }\n    });\n\n    // We need to filter out these legacy background_job frames so that they\n    // don't overlap with the nested background jobs\n    if (backgroundJobCount !== 0 && backgroundJobEndCount === 0) {\n      return framesOfInterest.filter(\n        (frame) => frame.type !== \"background_job\"\n      );\n    } else {\n      return framesOfInterest.filter((frame) => {\n        if (\n          \"qualname\" in frame &&\n          frame.qualname === \"celery.app.task.Task.apply_async\"\n        ) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  };\n}\n\nfunction removeEmptySqlQueries() {\n  return (framesOfInterest: FrameOfInterest[]): FrameOfInterest[] => {\n    return framesOfInterest.filter((frame, index, array) => {\n      const type = frame.type;\n      if (![\"start_sql_query\", \"end_sql_query\"].includes(String(type))) {\n        return true;\n      }\n\n      if (frame.type === \"start_sql_query\") {\n        let nextItem = array[index + 1];\n        if (nextItem.type !== \"end_sql_query\") {\n          // Sometimes a log message can sneak in between the start and end sql query\n          // which this branch accounts for. Ideally we'd operate on a tree here, but this simpler method will work for now.\n          nextItem = array[index + 2] as EndSQLQuery;\n        }\n        if (nextItem.type !== \"end_sql_query\") {\n          console.log(\n            \"Error: Expected end_sql_query after start_sql_query but got:\",\n            nextItem\n          );\n        }\n        if (nextItem.query === null) {\n          // If the end_sql_query query is null, then we want to filter out both.\n          // Including the current item (start_sql_query)\n          return false;\n        }\n      } else if (frame.type === \"end_sql_query\") {\n        if (frame.query === null) {\n          return false;\n        }\n      }\n      return true;\n    });\n  };\n}\n\ntype FrameTransform = (\n  framesOfInterest: FrameOfInterest[]\n) => FrameOfInterest[];\n\nconst preProcessFramesOfInterest: FrameTransform = pipe(\n  removeLegacyUrllibFrames(),\n  removeLegacyBackgroundJobFrames(),\n  removeEmptySqlQueries()\n);\n\nfunction pipe(...fns: Function[]) {\n  // Boilerplate functional pipe so that we can compose functions\n  // and do some nice chaining.\n  return (input: any) => fns.reduce((acc, fn) => fn(acc), input);\n}\n\nfunction setChildrenCounts(nodes: ExecutionTreeNode[]): void {\n  nodes.forEach((node) => {\n    node.children.forEach((child) => {\n      setChildrenCounts([child]);\n    });\n    node.all_children_count = calculateAllChildrenCount(node);\n  });\n}\n\nfunction postProcess(nodes: ExecutionTreeNode[]): ExecutionTreeNode[] {\n  // Remove entire subtrees by updating the node's parent's children to no longer include the node.\n  // Currently only removes django_setup subtrees\n\n  const removeChildrenOfTheseNodes = [\n    \"django_setup\",\n    \"django_checks\",\n    \"django_create_test_db\",\n  ];\n\n  const dfsGenerator = dfsWithParent(nodes);\n  for (const [node, parent] of dfsGenerator) {\n    if (removeChildrenOfTheseNodes.includes(node.type)) {\n      if (parent) {\n        parent.children = parent.children.filter((child) => child !== node);\n      } else {\n        nodes = nodes.filter((root) => root !== node);\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction frameMisMatchDebugInfo(\n  currentParent: ExecutionTreeNode,\n  frameOfInterest: FrameOfInterest,\n  allFramesOfInterest: FrameOfInterest[]\n): string {\n  const currentParentFrameId = currentParent.frame_id;\n  const currentReturnFrameOfInterestFrameId = frameOfInterest.frame_id;\n\n  const frameMisMatchDebugOutput = [];\n  let intermediateFrameCount = 0;\n  let indentationStack = [];\n\n  for (let frame of allFramesOfInterest) {\n    let callOrReturn;\n\n    if (!frame.type || frame.type === \"frame\") {\n      callOrReturn = frame.event;\n    } else {\n      if (callLikeFramesOfInterest.includes(frame.type)) {\n        callOrReturn = \"call\";\n      } else if (returnLikeFramesOfInterest.includes(frame.type)) {\n        callOrReturn = \"return\";\n      } else if (leafFramesOfInterest.includes(frame.type)) {\n        callOrReturn = \"leaf\";\n      } else {\n        callOrReturn = \"unknown_call_or_return\";\n      }\n    }\n\n    let indent = \"  \".repeat(indentationStack.length);\n\n    if (\n      frame.frame_id === currentParentFrameId ||\n      frame.frame_id === currentReturnFrameOfInterestFrameId\n    ) {\n      if (intermediateFrameCount > 0) {\n        frameMisMatchDebugOutput.push(\n          `${indent}(${intermediateFrameCount} frames)`\n        );\n        intermediateFrameCount = 0;\n      }\n\n      if (callOrReturn === \"call\") {\n        frameMisMatchDebugOutput.push(\n          `${indent}${callOrReturn} (${frame.type}) {${frame.frame_id}}`\n        );\n        indentationStack.push(callOrReturn);\n      } else if (callOrReturn === \"return\") {\n        if (indentationStack.length > 0) {\n          indentationStack.pop();\n        }\n        indent = \"  \".repeat(indentationStack.length); // Recalculate indent\n        frameMisMatchDebugOutput.push(\n          `${indent}${callOrReturn} (${frame.type}) {${frame.frame_id}}`\n        );\n      }\n    } else {\n      intermediateFrameCount++;\n    }\n  }\n\n  if (intermediateFrameCount > 0) {\n    const indent = \"  \".repeat(indentationStack.length);\n    frameMisMatchDebugOutput.push(\n      `${indent}(${intermediateFrameCount} frames)`\n    );\n  }\n\n  return frameMisMatchDebugOutput.join(\"\\n\");\n}\n\nfunction throwMissingReturnFrame(\n  currentParent: ExecutionTreeNode,\n  frameOfInterest: FrameOfInterest,\n  allFramesOfInterest: FrameOfInterest[]\n) {\n  // Called when we can't close a any execution tree node pair (frame or otherwise)\n\n  const debugOutput = frameMisMatchDebugInfo(\n    currentParent,\n    frameOfInterest,\n    allFramesOfInterest\n  );\n\n  throw new Error(\n    `Could not build tree\\n` +\n      `Frame with no corresponding return: ${currentParent.frame_id} (${currentParent.name})\\n\\n` +\n      debugOutput +\n      \"\\n\\n\"\n  );\n}\n// Debugging utility for drawing an entire execution tree from any node\n// using ASCII art and printing it in the console\n// @ts-ignore\nfunction drawTree(node: ExecutionTreeNode, prefix = \"\"): string {\n  let output = `${prefix}${node.name}\\n`;\n  const n = node.children.length;\n  node.children.forEach((child, index) => {\n    const newPrefix = index === n - 1 ? `${prefix}    ` : `${prefix}│   `;\n    output += drawTree(child, newPrefix);\n  });\n  return output;\n}\n","var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read().toString()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(property => property.toString()) // ensure that all keys are strings and that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// craete reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\t\t\n\t\tconst writeObject = checkUseRecords ? (object, safePrototype) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object,safePrototype) : writePlainObject(object,safePrototype)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048","import { addExtension, Packr } from \"msgpackr\";\n\nlet packr = new Packr({ useRecords: false });\n\n// DateTime extension\naddExtension({\n  type: 0,\n  unpack(buffer) {\n    return buffer.toString(\"utf-8\");\n  },\n});\n\naddExtension({\n  type: 1,\n  unpack(buffer) {\n    return buffer.toString(\"utf-8\");\n  },\n});\n\n// Date extension\naddExtension({\n  type: 2,\n  unpack(buffer) {\n    return buffer.toString(\"utf-8\");\n  },\n});\n\n// Time extension\naddExtension({\n  type: 3,\n  unpack(buffer) {\n    return buffer.toString(\"utf-8\");\n  },\n});\n\n// https://coolaj86.com/articles/convert-hex-to-decimal-with-js-bigints/\nfunction hexToBigInt(hex: String) {\n  if (hex.length % 2) {\n    hex = \"0\" + hex;\n  }\n\n  var highbyte = parseInt(hex.slice(0, 2), 16);\n  var bn = BigInt(\"0x\" + hex);\n\n  if (0x80 & highbyte) {\n    // bn = ~bn; WRONG in JS (would work in other languages)\n\n    // manually perform two's compliment (flip bits, add one)\n    // (because JS binary operators are incorrect for negatives)\n    bn =\n      BigInt(\n        \"0b\" +\n          bn\n            .toString(2)\n            .split(\"\")\n            .map(function (i: any) {\n              return \"0\" === i ? 1 : 0;\n            })\n            .join(\"\")\n      ) + BigInt(1);\n    // add the sign character to output string (bytes are unaffected)\n    bn = -bn;\n  }\n\n  return bn;\n}\n\n// Integer extension\naddExtension({\n  type: 4,\n  unpack(buffer) {\n    let hex = buffer.toString(\"hex\");\n    return hexToBigInt(hex);\n  },\n});\n\n// Decimal extension\naddExtension({\n  type: 5,\n  unpack(buffer) {\n    return Number(buffer.toString(\"utf-8\"));\n  },\n});\n\naddExtension({\n  type: 127,\n  unpack(buffer) {\n    let broken_class = buffer.toString(\"utf-8\");\n    return `SerializationError: Unserializable \\`${broken_class}\\` instance`;\n  },\n});\n\n// Turn this binary value mostly into the javascript object that JSON.parse\n// would give us. For now, set all locals to empty {} – so that we just deal with\n// the \"easier\" bits for now.\nexport function msgpackLoad(buffer: Uint8Array) {\n  return packr.unpack(buffer);\n}\n\n// [null, null] -> None, None\n// True / False (including in nested places)\n// datetimes as their repr (but we want the real datetime for test generation)\n","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n    constructor(options) {\n        this.options = options;\n        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\n    }\n    observe(element, listener) {\n        this._listeners.set(element, listener);\n        this._getObserver().observe(element, this.options);\n        return () => {\n            this._listeners.delete(element);\n            this._observer.unobserve(element); // this line can probably be removed\n        };\n    }\n    _getObserver() {\n        var _a;\n        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {\n            var _a;\n            for (const entry of entries) {\n                ResizeObserverSingleton.entries.set(entry.target, entry);\n                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n            }\n        }));\n    }\n}\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value == null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_iframe_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_iframe_resize_listener, add_location, add_render_callback, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","<script lang=\"ts\">\n  import \"./vscode.css\";\n  import \"./app.css\";\n  // Svelte component logic goes here\n</script>\n\n<!-- HTML markup -->\n<div class=\"m-4\">\n  <h1 class=\"text-4xl mb-4 font-bold\">Kolo</h1>\n  <div id=\"traces\" class=\"flex flex-col\" />\n</div>\n\n<style>\n  /* CSS for your component */\n</style>\n","import { makeExecutionTree } from \"../build-frame-tree\";\nimport { msgpackLoad } from \"../extension/msgpack\";\n\nimport WebApp from \"./WebApp.svelte\";\n\nasync function loadVizForTrace(traceId: string) {\n  const trace = await fetch(`api/traces/${traceId}/`);\n\n  let parsed_trace;\n  if (trace.headers.get(\"content-type\") === \"application/msgpack\") {\n    parsed_trace = msgpackLoad(new Uint8Array(await trace.arrayBuffer()));\n  } else {\n    parsed_trace = await trace.json();\n  }\n\n  const tree = makeExecutionTree(parsed_trace.frames_of_interest);\n\n  window.dispatchEvent(\n    new CustomEvent(\"web-load-viz\", {\n      detail: { tree, traceId },\n    })\n  );\n}\n\nasync function main() {\n  new WebApp({\n    target: document.getElementById(\"app\") as HTMLElement,\n  });\n\n  const latest_traces = await (await fetch(\"api/latest-traces/\")).json();\n\n  const tracesElement = document.getElementById(\"traces\");\n  tracesElement!.innerHTML = latest_traces.traces\n    .map((trace_id: string) => {\n      return (\n        '<div class=\"trace my-1 p-2 border-2 rounded-md cursor-pointer\">' +\n        trace_id +\n        \"</div>\"\n      );\n    })\n    .join(\"\");\n\n  const traceElements = document.getElementsByClassName(\"trace\");\n  // @ts-ignore\n  for (const traceElement of traceElements) {\n    // @ts-ignore\n    traceElement.addEventListener(\"click\", (event) => {\n      // @ts-ignore\n      const trace_id = event.target.innerHTML;\n      loadVizForTrace(trace_id);\n    });\n  }\n\n  const latest_trace_id = latest_traces.traces[0];\n  loadVizForTrace(latest_trace_id);\n  window\n    .matchMedia(\"(prefers-color-scheme: dark)\")\n    .addEventListener(\"change\", () => {\n      window.dispatchEvent(\n        new CustomEvent(\"message\", { detail: { command: \"themeChange\" } })\n      );\n    });\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", main);\n"],"sourceRoot":""}